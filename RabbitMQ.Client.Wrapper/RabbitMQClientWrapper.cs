using System;
using System.Text;
using DotNetCoreCommon;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using RabbitMQ.Client.Events;
using RabbitMQ.Client.Wrapper.Abstractions;

namespace RabbitMQ.Client.Wrapper
{
	public class RabbitMQClientWrapper : IRabbitMQClientWrapper
	{
		#region Private

		private readonly ILogger _logger = null;
		private readonly IRabbitMQConfig _rabbitMQConfig = null;
		private EventingBasicConsumer _eventingBasicConsumer = null;
		private bool _isPublisherConfirmEnabled = false;
		private bool _initialized = false;

		#endregion

		#region Public

		public RabbitMQClientWrapper(ILogger<RabbitMQClientWrapper> logger, IRabbitMQConfig rabbitMQConfig)
		{
			_logger = logger;
			_rabbitMQConfig = rabbitMQConfig;

			_logger.LogDebug($"Constructed");
		}

		public IConnection Connection { get; private set; }

		public IModel Model { get; private set; }

		public void Initialize()
		{
			_logger.LogInformation($"Initializing.  _initialized={_initialized}");
			if (_initialized) return;

			_rabbitMQConfig.Initialize();

			var connectionFactory = new ConnectionFactory();
			connectionFactory.HostName = _rabbitMQConfig.Connection.HostName;
			connectionFactory.UserName = _rabbitMQConfig.Connection.UserName;
			connectionFactory.Password = _rabbitMQConfig.Connection.Password;

			Connection = connectionFactory.CreateConnection();
			_logger.LogDebug($"Connection created {Connection}");
			Model = Connection.CreateModel();
			_logger.LogDebug($"Model created {Model}");

			IExchangeConfig exchangeConfig = _rabbitMQConfig.Exchange;
			_logger.LogDebug($"exchangeConfig: {JsonConvert.SerializeObject(exchangeConfig)}");

			if (exchangeConfig != null)
			{
				Model.ExchangeDeclare(
						exchange: exchangeConfig.Name,
						type: exchangeConfig.Type,
						autoDelete: exchangeConfig.AutoDelete.Value,
						durable: exchangeConfig.Durable.Value,
						arguments: exchangeConfig.Arguments);
				_logger.LogDebug($"ExchangeDeclare completed.  exchange={exchangeConfig.Name}, type={exchangeConfig.Type}, autoDelete={exchangeConfig.AutoDelete}, durable={exchangeConfig.Durable}, arguments={exchangeConfig.Arguments}");
			}

			if (_rabbitMQConfig.Queue != null)
			{
				IQueueConfig queueConfig = _rabbitMQConfig.Queue;
				_logger.LogDebug($"queueConfig: {JsonConvert.SerializeObject(queueConfig)}");

				var queueDeclareOk = Model.QueueDeclare(
					queue: queueConfig.Name,
					exclusive: queueConfig.Exclusive.Value,
					autoDelete: queueConfig.AutoDelete.Value,
					durable: queueConfig.Durable.Value,
					arguments: queueConfig.Arguments);
				_logger.LogDebug($"QueueDeclare completed.  queue={queueConfig.Name}, exclusive={queueConfig.Exclusive}, autoDelete={queueConfig.AutoDelete}, durable={queueConfig.Durable}, arguments={queueConfig.Arguments}, queueDeclareOk ={queueDeclareOk}");

				if (queueConfig.Name.Length == 0)
				{
					queueConfig.SetAutoGeneratedQueueName(queueDeclareOk.QueueName);
					_logger.LogDebug($"SetAutoGeneratedQueueName completed.  queue={queueDeclareOk.QueueName}");
				}
			}

			if (_rabbitMQConfig.BasicQosConfig != null)
			{
				Model.BasicQos(
					prefetchSize: _rabbitMQConfig.BasicQosConfig.PrefetchSize.Value,
					prefetchCount: _rabbitMQConfig.BasicQosConfig.PrefetchCount.Value,
					global: _rabbitMQConfig.BasicQosConfig.Global.Value);
			}

			if (_rabbitMQConfig.QueueBinding != null)
			{
				_logger.LogDebug($"queueBindingConfig: {JsonConvert.SerializeObject(_rabbitMQConfig.QueueBinding)}");

				foreach (string routingKey in _rabbitMQConfig.QueueBinding.RoutingKeys)
				{
					QueueBind(routingKey: routingKey);
				}
			}

			if (_rabbitMQConfig.ConfirmSelectConfig != null && _rabbitMQConfig.ConfirmSelectConfig.Enabled.Value)
			{
				Model.ConfirmSelect();
				_logger.LogDebug($"ConfirmSelect completed.");
			}

			if (_rabbitMQConfig.TestConfig != null && _rabbitMQConfig.TestConfig.SendTestMessageOnStart.Value)
			{
				IExchangeConfig testExchangeConfig = _rabbitMQConfig.Exchange;
				_logger.LogDebug($"exchangeConfig: {JsonConvert.SerializeObject(exchangeConfig)}");

				BasicPublish(_rabbitMQConfig.TestConfig.RoutingKey, _rabbitMQConfig.TestConfig.TestMessage.ToUtf8Bytes());
			}

			_initialized = true;
		}

		public void BasicPublish(byte[] body)
		{
			BasicPublish(_rabbitMQConfig.BasicPublishConfig.RoutingKey, body);
		}

		public void BasicPublish(string routingKey, byte[] body)
		{
			BasicPublish(routingKey, body, false, out bool timedOut);
		}

		public void BasicPublish(string routingKey, byte[] body, bool shouldWaitForConfirms, out bool timedOut)
		{
			string exchange = _rabbitMQConfig.Exchange != null ? _rabbitMQConfig.Exchange.Name : "";
			IBasicProperties basicProperties = null;
			if (_rabbitMQConfig.BasicPublishConfig != null && _rabbitMQConfig.BasicPublishConfig.BasicProperitesConfig != null)
			{
				basicProperties = Model.CreateBasicProperties();
				basicProperties.Persistent = _rabbitMQConfig.BasicPublishConfig.BasicProperitesConfig.Persistent.Value;
			}
			BasicPublish(exchange, routingKey, body, basicProperties, shouldWaitForConfirms, out timedOut);
		}

		public void BasicPublish(string exchange, string routingKey, byte[] body, IBasicProperties basicProperties, bool shouldWaitForConfirms, out bool timedOut)
		{
			timedOut = false;
			Model.BasicPublish(
				exchange: exchange,
				routingKey: routingKey,
				mandatory: false,
				basicProperties: basicProperties,
				body: body);

			var message = (body?.FromUtf8ToString() ?? "");
			var message80 = message.Substring(0, Math.Min(80, message.Length));

			_logger.LogInformation($"BasicPublish completed: exchange={exchange}, routingKey={routingKey}, mandatory=false, basicProperties=null,body={body} Utf8String(80 chars)={message80}");
			if (_isPublisherConfirmEnabled)
			{
				if (shouldWaitForConfirms)
				{
					Model.WaitForConfirms(TimeSpan.FromMilliseconds(_rabbitMQConfig.ConfirmSelectConfig.TimeoutInMs.Value), out timedOut);
				}
			}
		}

		public void QueueBind(string routingKey)
		{
			Model.QueueBind(
				queue: _rabbitMQConfig.Queue.Name,
				exchange: _rabbitMQConfig.Exchange.Name,
				routingKey: routingKey);
			_logger.LogDebug($"QueueBind completed: Name={_rabbitMQConfig.Queue.Name}, exchange={_rabbitMQConfig.Exchange.Name} routingKey={routingKey}");
		}

		public void BasicConsume()
		{
			bool autoAck = _rabbitMQConfig.BasicConsumeConfig != null ? _rabbitMQConfig.BasicConsumeConfig.AutoAck.Value : true;
			Model.BasicConsume(
				queue: _rabbitMQConfig.Queue.Name,
				autoAck: autoAck,
				consumer: EventingBasicConsumer);
			_logger.LogInformation($"BasicConsume completed: queue={_rabbitMQConfig.Queue.Name}, autoAck={autoAck}, consumer={EventingBasicConsumer}");
		}

		public void BasicAck(ulong deliveryTag, bool multiple)
		{
			Model.BasicAck(deliveryTag: deliveryTag, multiple: multiple);
			_logger.LogDebug($"BasicAck completed: deliveryTag={deliveryTag}, multiple={multiple}");
		}

		public EventingBasicConsumer EventingBasicConsumer
		{
			get
			{
				if (_eventingBasicConsumer == null)
				{
					_eventingBasicConsumer = new EventingBasicConsumer(Model);
				}
				return _eventingBasicConsumer;
			}
		}

		public void Uninitialize()
		{
			_logger.LogInformation($"Uninitializing.");
			if (Model != null)
			{
				Model.Dispose();
				Model = null;
			}

			if (Connection != null)
			{
				Connection.Dispose();
				Connection = null;
			}
		}

		#endregion

		#region IRabbitMQClientWarpper interface
		IConnection IRabbitMQClientWrapper.Connection => Connection;
		IModel IRabbitMQClientWrapper.Model => Model;
		EventingBasicConsumer IRabbitMQClientWrapper.EventingBasicConsumer => EventingBasicConsumer;
		void IRabbitMQClientWrapper.BasicAck(ulong deliveryTag, bool multiple) => BasicAck(deliveryTag, multiple);
		void IRabbitMQClientWrapper.BasicConsume() => BasicConsume();
		void IRabbitMQClientWrapper.BasicPublish(byte[] body) => BasicPublish(body);
		void IRabbitMQClientWrapper.BasicPublish(string body) => BasicPublish(Encoding.UTF8.GetBytes(body));
		void IRabbitMQClientWrapper.BasicPublish(string routingKey, byte[] body) => BasicPublish(routingKey, body);
		void IRabbitMQClientWrapper.BasicPublish(string routingKey, byte[] body, bool shouldWaitForConfirms, out bool timedOut) => BasicPublish(routingKey, body, shouldWaitForConfirms, out timedOut);
		void IRabbitMQClientWrapper.QueueBind(string routingKey) => QueueBind(routingKey);
		#endregion

	}
}
